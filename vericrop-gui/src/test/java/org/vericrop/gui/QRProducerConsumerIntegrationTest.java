package org.vericrop.gui;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.vericrop.gui.util.QRDecoder;
import org.vericrop.gui.util.QRGenerator;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for the QR code generation (ProducerController) and 
 * scanning/parsing (ConsumerController) flow.
 * 
 * <p>These tests verify that:</p>
 * <ul>
 *   <li>QR codes generated by ProducerController can be decoded by ConsumerController</li>
 *   <li>Batch IDs are extracted correctly from various QR formats</li>
 *   <li>Quality information is preserved across the generate/scan cycle</li>
 *   <li>Fallback batch ID extraction works for edge cases</li>
 * </ul>
 * 
 * <p>This addresses the issue where QR codes generated by ProducerController 
 * could not be scanned by ConsumerController, causing a "Batch ID Not Found" popup.</p>
 */
class QRProducerConsumerIntegrationTest {
    
    @AfterEach
    void cleanup() throws IOException {
        // Clean up generated QR codes after each test
        Path qrDir = QRGenerator.getQROutputDirectory();
        if (Files.exists(qrDir)) {
            Files.walk(qrDir)
                .filter(Files::isRegularFile)
                .filter(p -> p.toString().endsWith(".png"))
                .forEach(p -> {
                    try {
                        Files.deleteIfExists(p);
                    } catch (IOException e) {
                        // Ignore cleanup errors
                    }
                });
        }
    }
    
    /**
     * Test the complete Producer -> QR -> Consumer flow with quality information.
     * This is the primary use case that was failing.
     */
    @Test
    void testProducerToConsumerFlow_WithQuality() throws Exception {
        // Simulate ProducerController generating a batch QR code
        String batchId = "BATCH_1764759800_304";  // Format used in the issue
        String farmerId = "Unknown Farmer";
        String quality = "PRIME";
        
        // Generate QR code (as ProducerController.handleGenerateQR does)
        Path qrPath = QRGenerator.generateBatchQR(batchId, farmerId, quality);
        assertTrue(Files.exists(qrPath), "QR code should be generated");
        
        // Simulate ConsumerController scanning the QR code (as handleScanQR does)
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertNotNull(qrContent, "QR content should be decoded");
        
        // Parse the payload (as ConsumerController does)
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        assertNotNull(payload, "Payload should be parsed successfully");
        
        // Verify batch ID extraction
        String extractedBatchId = payload.getBatchId();
        assertEquals(batchId, extractedBatchId, "Batch ID should match the original");
        
        // Verify quality extraction
        String extractedQuality = payload.getQuality();
        assertEquals(quality, extractedQuality, "Quality should match the original");
        
        // Also verify the fallback extraction method works
        String fallbackBatchId = QRDecoder.extractBatchId(qrContent);
        assertEquals(batchId, fallbackBatchId, "Fallback extraction should also work");
    }
    
    /**
     * Test the flow with null quality (some batches may not have quality set).
     */
    @Test
    void testProducerToConsumerFlow_WithNullQuality() throws Exception {
        String batchId = "BATCH_" + System.currentTimeMillis();
        String farmerId = "Test Farmer";
        
        // Generate QR code without quality
        Path qrPath = QRGenerator.generateBatchQR(batchId, farmerId, null);
        assertTrue(Files.exists(qrPath), "QR code should be generated");
        
        // Decode and parse
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        // Verify batch ID
        assertEquals(batchId, payload.getBatchId(), "Batch ID should match");
        
        // Quality should be null or handled gracefully
        assertNull(payload.getQuality(), "Quality should be null");
        assertEquals("Unknown", payload.getQualityOrUnknown(), "Should return Unknown for missing quality");
    }
    
    /**
     * Test that legacy product QR codes (pre-versioned format) still work.
     */
    @Test
    void testLegacyProductQRFormat() throws Exception {
        String productId = "BATCH_LEGACY_001";
        String farmerId = "Legacy Farmer";
        
        // Generate legacy format QR code
        Path qrPath = QRGenerator.generateProductQR(productId, farmerId);
        assertTrue(Files.exists(qrPath), "QR code should be generated");
        
        // Decode and parse
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        // Verify backward compatibility
        assertNotNull(payload, "Legacy format should be parseable");
        assertEquals(productId, payload.getBatchId(), "Batch ID should be extracted");
        assertTrue(payload.isLegacyProduct(), "Should be identified as legacy product");
    }
    
    /**
     * Test that the batch ID format matches what the backend expects.
     * The backend stores batch IDs as "BATCH_{timestamp}_{random}".
     */
    @Test
    void testBatchIdFormatConsistency() throws Exception {
        // Generate batch ID in the same format the backend uses
        // Add test identifier to avoid conflicts with other tests
        long timestamp = System.currentTimeMillis();
        int random = (int) (Math.random() * 9000) + 1000; // 4-digit random to avoid conflicts
        String batchId = String.format("BATCH_%d_%d_FORMAT_TEST", timestamp, random);
        
        // Generate and decode QR
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", "STANDARD");
        assertTrue(Files.exists(qrPath), "QR file should exist after generation");
        
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertNotNull(qrContent, "QR content should not be null");
        
        String extractedId = QRDecoder.extractBatchId(qrContent);
        
        // The extracted ID should exactly match the original
        assertEquals(batchId, extractedId, "Batch ID format should be preserved exactly");
        
        // Verify format with regex (modified to include test suffix)
        Pattern batchIdPattern = Pattern.compile("BATCH_\\d+_\\d+_FORMAT_TEST");
        Matcher matcher = batchIdPattern.matcher(extractedId);
        assertTrue(matcher.matches(), "Batch ID should match expected pattern BATCH_{timestamp}_{random}_FORMAT_TEST");
    }
    
    /**
     * Test all quality levels to ensure they're preserved.
     */
    @Test
    void testAllQualityLevels() throws Exception {
        String[] qualityLevels = {"PRIME", "STANDARD", "SUB-STANDARD"};
        String uniqueId = String.valueOf(System.nanoTime()); // Unique per test run
        
        for (String expectedQuality : qualityLevels) {
            String batchId = "BATCH_QUALITY_" + expectedQuality.replace("-", "_") + "_" + uniqueId;
            
            // Generate QR
            Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", expectedQuality);
            assertTrue(Files.exists(qrPath), "QR file should exist for " + expectedQuality);
            
            // Decode and verify
            String qrContent = QRDecoder.decodeQRCode(qrPath);
            assertNotNull(qrContent, "QR content should not be null for " + expectedQuality);
            
            QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
            
            assertEquals(batchId, payload.getBatchId(), 
                "Batch ID should match for quality level: " + expectedQuality);
            assertEquals(expectedQuality, payload.getQuality(), 
                "Quality should match: " + expectedQuality);
        }
    }
    
    /**
     * Test that special characters in batch ID are handled correctly.
     */
    @Test
    void testSpecialCharactersInBatchId() throws Exception {
        String uniqueId = String.valueOf(System.nanoTime());
        
        // Test with hyphen (common in batch IDs)
        String batchIdWithHyphen = "BATCH-ABC-" + uniqueId;
        Path qrPath = QRGenerator.generateBatchQR(batchIdWithHyphen, "farmer", "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertEquals(batchIdWithHyphen, QRDecoder.extractBatchId(qrContent), 
            "Batch ID with hyphens should be preserved");
        
        // Test with underscore (common in batch IDs) - also make unique
        String batchIdWithUnderscore = "BATCH_ABC_" + uniqueId;
        qrPath = QRGenerator.generateBatchQR(batchIdWithUnderscore, "farmer", "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist for underscore test");
        qrContent = QRDecoder.decodeQRCode(qrPath);
        assertEquals(batchIdWithUnderscore, QRDecoder.extractBatchId(qrContent), 
            "Batch ID with underscores should be preserved");
    }
    
    /**
     * Test the versioned format type identification.
     */
    @Test
    void testVersionedFormatIdentification() throws Exception {
        String uniqueId = String.valueOf(System.nanoTime());
        String batchId = "BATCH_VERSIONED_" + uniqueId;
        
        // Generate versioned batch QR
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        // Verify versioned format markers
        assertTrue(payload.isVersionedBatch(), "Should be identified as versioned batch");
        assertEquals(QRGenerator.TYPE_VERICROP_BATCH, payload.getType(), 
            "Type should be vericrop-batch");
        assertEquals(QRGenerator.QR_FORMAT_VERSION, payload.getVersion(), 
            "Version should match QR_FORMAT_VERSION");
    }
    
    /**
     * Test that the farmer ID (seed) is preserved through the encode/decode cycle.
     */
    @Test
    void testFarmerIdPreserved() throws Exception {
        String uniqueId = String.valueOf(System.nanoTime());
        String batchId = "BATCH_FARMER_TEST_" + uniqueId;
        String farmerId = "farmer_abc123";
        
        Path qrPath = QRGenerator.generateBatchQR(batchId, farmerId, "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        assertEquals(farmerId, payload.getFarmerId(), "Farmer ID should be preserved");
    }
    
    /**
     * Test timestamp is present in versioned format.
     */
    @Test
    void testTimestampPresent() throws Exception {
        String uniqueId = String.valueOf(System.nanoTime());
        String batchId = "BATCH_TIMESTAMP_TEST_" + uniqueId;
        
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        assertNotNull(payload.getTimestamp(), "Timestamp should be present");
        assertTrue(payload.getTimestamp().length() > 0, "Timestamp should not be empty");
    }
    
    /**
     * Simulate the exact flow from the issue: BATCH_1764759800_304 format.
     * This test replicates the reported failure scenario.
     */
    @Test
    void testExactIssueScenario() throws Exception {
        // Use a unique batch ID based on the format from the issue
        // Adding uniqueId to avoid conflicts with other test runs
        String uniqueId = String.valueOf(System.nanoTime() % 1000);
        String batchId = "BATCH_1764759800_" + uniqueId;
        String farmerId = "Unknown Farmer";
        String quality = "PRIME";
        
        // Step 1: Producer generates QR
        Path qrPath = QRGenerator.generateBatchQR(batchId, farmerId, quality);
        assertNotNull(qrPath, "QR should be generated");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        
        // Step 2: Consumer scans QR
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertNotNull(qrContent, "QR should be decodable");
        
        // Step 3: Consumer parses payload
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        assertNotNull(payload, "Payload should be parsed");
        
        // Step 4: Verify the batch ID is correctly extracted
        // This is where the original issue occurred - batch ID was not being 
        // properly extracted or matched
        assertEquals(batchId, payload.getBatchId(), 
            "Batch ID should be extracted correctly - this was failing in the reported issue");
        
        // Step 5: The backend lookup would use this batch ID
        // The fix adds GET /batches/{batch_id} endpoint to the backend
        // which will return the batch data or 404 if not found
        
        // This test verifies the QR encode/decode cycle works correctly
        // The backend endpoint test would be in a separate integration test
    }
}
