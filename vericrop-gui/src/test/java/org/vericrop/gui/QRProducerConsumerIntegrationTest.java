package org.vericrop.gui;

import org.junit.jupiter.api.Test;
import org.vericrop.gui.util.QRDecoder;
import org.vericrop.gui.util.QRGenerator;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for the QR code generation (ProducerController) and 
 * scanning/parsing (ConsumerController) flow.
 * 
 * <p>These tests verify that:</p>
 * <ul>
 *   <li>QR codes generated by ProducerController can be decoded by ConsumerController</li>
 *   <li>Batch IDs are extracted correctly from various QR formats</li>
 *   <li>Quality information is preserved across the generate/scan cycle</li>
 * </ul>
 * 
 * <p>This addresses the issue where QR codes generated by ProducerController 
 * could not be scanned by ConsumerController, causing a "Batch ID Not Found" popup.</p>
 * 
 * <p>Note: More detailed QR encoding/decoding tests are in QRGeneratorTest and QRDecoderTest.
 * This class focuses on the Producer-Consumer contract.</p>
 */
class QRProducerConsumerIntegrationTest {
    
    /** Pre-compiled pattern for batch ID format verification (BATCH_{timestamp}_{random}_{suffix}) */
    private static final Pattern BATCH_ID_FORMAT_PATTERN = Pattern.compile("BATCH_\\d+_\\d+_FORMAT_TEST");
    
    /**
     * Generate a unique test identifier to avoid file collisions in concurrent test execution.
     * Uses UUID substring for guaranteed uniqueness.
     */
    private static String uniqueId() {
        return UUID.randomUUID().toString().substring(0, 8);
    }
    
    /**
     * Test that the batch ID format matches what the backend expects.
     * The backend stores batch IDs as "BATCH_{timestamp}_{random}".
     * 
     * This verifies the exact format used in the reported issue: BATCH_1764759800_304
     */
    @Test
    void testBatchIdFormatConsistency() throws Exception {
        // Generate batch ID in the same format the backend uses
        // Add test identifier to avoid conflicts with other tests
        long timestamp = System.currentTimeMillis();
        int random = (int) (Math.random() * 9000) + 1000; // 4-digit random to avoid conflicts
        String batchId = String.format("BATCH_%d_%d_FORMAT_TEST", timestamp, random);
        
        // Generate and decode QR
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", "STANDARD");
        assertTrue(Files.exists(qrPath), "QR file should exist after generation");
        
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertNotNull(qrContent, "QR content should not be null");
        
        String extractedId = QRDecoder.extractBatchId(qrContent);
        
        // The extracted ID should exactly match the original
        assertEquals(batchId, extractedId, "Batch ID format should be preserved exactly");
        
        // Verify format with pre-compiled regex pattern
        Matcher matcher = BATCH_ID_FORMAT_PATTERN.matcher(extractedId);
        assertTrue(matcher.matches(), "Batch ID should match expected pattern BATCH_{timestamp}_{random}_FORMAT_TEST");
    }
    
    /**
     * Test that quality is preserved through the encode/decode cycle.
     * This is critical for the ConsumerController verification flow.
     */
    @Test
    void testQualityPreserved() throws Exception {
        String uniqueId = uniqueId();
        String batchId = "BATCH_QUALITY_" + uniqueId;
        String expectedQuality = "PRIME";
        
        // Generate QR with quality
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", expectedQuality);
        assertTrue(Files.exists(qrPath), "QR file should exist");
        
        // Decode and parse
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        assertNotNull(qrContent, "QR content should not be null");
        
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        assertNotNull(payload, "Payload should be parsed");
        
        // Verify both batch ID and quality
        assertEquals(batchId, payload.getBatchId(), "Batch ID should match");
        assertEquals(expectedQuality, payload.getQuality(), "Quality should match");
    }
    
    /**
     * Verify the versioned batch format is correctly identified.
     * ConsumerController uses this to distinguish batch QRs from legacy product QRs.
     */
    @Test
    void testVersionedFormatIdentification() throws Exception {
        String uniqueId = uniqueId();
        String batchId = "BATCH_VERSIONED_" + uniqueId;
        
        // Generate versioned batch QR
        Path qrPath = QRGenerator.generateBatchQR(batchId, "farmer", "PRIME");
        assertTrue(Files.exists(qrPath), "QR file should exist");
        String qrContent = QRDecoder.decodeQRCode(qrPath);
        QRDecoder.QRPayload payload = QRDecoder.parsePayload(qrContent);
        
        // Verify versioned format markers
        assertTrue(payload.isVersionedBatch(), "Should be identified as versioned batch");
        assertEquals(QRGenerator.TYPE_VERICROP_BATCH, payload.getType(), 
            "Type should be vericrop-batch");
    }
}

